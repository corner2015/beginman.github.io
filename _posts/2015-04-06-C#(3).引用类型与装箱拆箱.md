---
layout: post
title: "C#(3).引用类型与装箱拆箱"
description: "C#(3).引用类型与装箱拆箱"
category: "C#"
tags: [C#]
---
{% include JB/setup %}
<ul>
    <li>作者：<a href="http://weibo.com/beginman" target="blank">BeginMan</a></li>
    <li>本文地址：http://beginman.github.io</li>
    <li>转载请注明出处</li>
</ul>
<h2>1.Object</h2>

<p>Object类型是C#根类型，提供了<code>Equals</code>,<code>GetHashCode</code>,<code>GetType</code>,<code>ToString</code>等常用方法。</p>

<p><a href="https://msdn.microsoft.com/zh-cn/library/System.Object_methods(v=vs.110).aspx">Object类方法</a>
其中c# equals与==的区别参考这里:<a href="http://www.cnblogs.com/jiahaipeng/archive/2008/04/11/1146316.html">c# equals与==的区别</a></p>

<pre><code>    //Object类型
    public static void objDemo()
    {
        /*
         * object类型是Object的别名，在C#中所有类型都是从Object继承的
         * 装箱：值类型 --&gt; 对象类型, 可以将所有值类型赋值给object类型的变量
         * 拆箱：对象类型 --&gt; 值类型， 将对象类型转换成值类型的过程
         */
        object a;
        a = 1;
        Console.WriteLine("a:{0}; type:{1}; toString:{2}", a, a.GetType(), a.ToString());
    }
</code></pre>

<h2>2.String</h2>

<pre><code>    //字符串类型
    // ref:https://msdn.microsoft.com/zh-cn/library/362314fe.aspx
    public static void StringDemo()
    { 
        /*
         * string类型表示一个字符序列,是String的别名
         * string是引用类型，但定义的==,!=是比较其值而非引用
         */
        string a = "hello";
        string b = "world";

        //字符串不可变：字符串在创建后尽管可以任意改变其值，实则创建临时字符串对象保存新的字符序列然后赋值过去
        b += "Jack";
        Console.WriteLine(b);

        //[]运算符可以对string字符进行只读访问
        char x = b[0];
        Console.WriteLine("x is {0} and elem is {1}", x, b[1]);

        //string转义用\表示，如反斜杠\\；  @表示原义输出
        string path = "C:\\Docs\\Cdemo\\demo.cs";
        Console.WriteLine(path);
        string path2 = @"C:\Docs\demo\demo.cs";
        Console.WriteLine(path2);


    }
</code></pre>

<h2>3.装箱与拆箱</h2>

<p>装箱是将值类型转换为引用类型 ；拆箱是将引用类型转换为值类型</p>

<p>利用装箱和拆箱功能，可通过允许值类型的任何值与Object 类型的值相互转换，将值类型与引用类型链接起来</p>

<p><strong>为何需要装箱？(为何要将值类型转为引用类型？)</strong> ：</p>

<p>一种最普通的场景是，调用一个含类型为Object的参数的方法，该Object可支持任意为型，以便通用。当你需要将一个值类型(如Int32)传入时，需要装箱。 
另一种用法是，一个非泛型的容器，同样是为了保证通用，而将元素类型定义为Object。于是，要将值类型数据加入容器时，需要装箱。</p>

<pre><code>    //装箱与拆箱
    // ref:http://www.cnblogs.com/huashanlin/archive/2007/05/16/749359.html
    public static void BoxingAndUnboxing()
    {
        /*
         *  装箱是将值类型转换为引用类型 ；拆箱是将引用类型转换为值类型 
         *  被装过箱的对象才能被拆箱
         */
        int val = 100;
        object a = val;
        Console.WriteLine("装箱过程 a={0}, a的类型为:{1}, a的值为:{2}", a, a.GetType(), a.ToString());

        int num = (int)a;
        Console.WriteLine("拆箱过程 num={0}, num的类型为:{1}, num的值为：{2}", num, num.GetType(), num.ToString());

    }
</code></pre>
